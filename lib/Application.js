// Generated by CoffeeScript 1.7.1
(function() {
  var ChildDirective, CustomDirective, Directive, DirectoryManager, FileManager, Log, MegaFile, NameDirective, NeedDirective, PHPRouteBuilder, ParentDirective, RenderDirective, RenderLine, RepeatDirective, RouteBuilder, SectionDirective, StopDirective, async, fs, mkdirp, os, path,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  fs = require("fs");

  RouteBuilder = (function() {
    function RouteBuilder(jsonFile) {
      this.file = jsonFile;
      this.load(this.file);
      this.parseRoute(this.routes);
    }

    RouteBuilder.prototype.load = function(file) {
      var content;
      content = fs.readFileSync(file, {
        encoding: "utf8"
      });
      this.routes = JSON.parse(content);
      return this.routes;
    };

    RouteBuilder.prototype.parseRoute = function(settings) {
      var match, p, param, parameter, rawParam, result, route, _i, _j, _len, _len1, _ref, _results;
      parameter = new RegExp("{.*?}", "g");
      _ref = settings.routes;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        route = _ref[_i];
        param = [];
        while ((result = parameter.exec(route.url))) {
          rawParam = result[0].replace(/({|})/g, "");
          rawParam = rawParam.split(" ");
          param.push(rawParam);
        }
        match = route.url;
        for (_j = 0, _len1 = param.length; _j < _len1; _j++) {
          p = param[_j];
          if (p.length === 1) {
            p.push("[^/]+");
          }
          match = match.replace(new RegExp("{ ?" + p[0] + ".*?}"), p[1]);
        }
        _results.push(route.match = match);
      }
      return _results;
    };

    RouteBuilder.prototype["export"] = function(file) {
      this.routes;
      return fs.writeFile(file, JSON.stringify(this.routes, null, 2));
    };

    return RouteBuilder;

  })();

  exports.RouteBuilder = RouteBuilder;

  PHPRouteBuilder = (function(_super) {
    __extends(PHPRouteBuilder, _super);

    function PHPRouteBuilder(file) {
      PHPRouteBuilder.__super__.constructor.call(this, file);
    }

    PHPRouteBuilder.prototype.object = function(object) {
      var str;
      str = JSON.stringify(object);
      return console.log(str);
    };

    return PHPRouteBuilder;

  })(RouteBuilder);

  exports.PHPRouteBuilder = PHPRouteBuilder;

  fs = require("fs");

  MegaFile = require("mega-reader").MegaFile;

  FileManager = (function() {
    function FileManager(filename, callback, stack) {
      this.filename = filename;
      this.callback = callback != null ? callback : null;
      this.stack = stack;
      this.mr = new MegaFile([this.filename]);
      this.tools = [];
      this.needed = [];
      this.section = [];
      this.child = [];
      this.buildtools();
      this.analyze();
    }

    FileManager.prototype.repeat = null;

    FileManager.prototype.needed = null;

    FileManager.prototype.parent = null;

    FileManager.prototype.section = null;

    FileManager.prototype.name = null;

    FileManager.prototype.child = null;

    FileManager.prototype.renderline = null;

    FileManager.prototype.analyze = function() {
      var cd, file, named, nd, pd, rd, sd;
      file = fs.readFileSync(this.filename, {
        encoding: "utf8"
      });
      if ((new RenderDirective).canHandle(file)) {
        this.render = true;
      }
      if ((rd = new RepeatDirective).canHandle(file)) {
        this.repeat = rd.getDirective(file).value;
      }
      if ((nd = new NeedDirective).canHandle(file)) {
        this.needed.push(nd.getDirective(file).value);
      }
      if ((pd = new ParentDirective).canHandle(file)) {
        this.parent = pd.getDirective(file).value;
      }
      if ((sd = new SectionDirective).canHandle(file)) {
        this.section.push(sd.getDirective(file).value);
      }
      if ((named = new NameDirective).canHandle(file)) {
        this.name = named.getDirective(file).value;
      }
      if ((cd = new ChildDirective).canHandle(file)) {
        this.child.push(cd.getDirective(file).value);
      }
      return this.callback.call();
    };

    FileManager.prototype.build = function(callback) {
      if (this.render) {
        this.buildRenderLine();
      }
      return callback.call();
    };

    FileManager.prototype.buildRenderLine = function() {
      var item;
      process.output.debug("building renderline");
      this.renderline = new RenderLine(this.name, this.stack);
      item = this;
      while (true) {
        if (!item) {
          break;
        }
        this.renderline.unshift(item);
        item = item.getParent();
      }
      return this.renderline.render();
    };

    FileManager.prototype.toString = function() {
      var obj;
      obj = {
        name: this.name,
        parent: this.parent,
        needed: this.needed,
        sections: this.section,
        repeat: this.repeat,
        render: this.render,
        child: this.child
      };
      return JSON.stringify(obj, void 0, 2);
    };

    FileManager.prototype.buildtools = function() {
      var tool, _i, _len, _ref, _results;
      _ref = [new NeedDirective, new ParentDirective, new RepeatDirective, new SectionDirective];
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        tool = _ref[_i];
        _results.push(this.tools.push(tool));
      }
      return _results;
    };

    FileManager.prototype.getParent = function() {
      var fm, _i, _len, _ref;
      if (!this.parent) {
        return this.parent;
      }
      _ref = this.stack;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        fm = _ref[_i];
        if (fm.name === this.parent) {
          return fm;
        }
      }
    };

    return FileManager;

  })();

  Directive = (function() {
    function Directive(symbol, input, parent) {
      var _base, _base1;
      this.symbol = symbol;
      this.input = input != null ? input : null;
      this.parent = parent != null ? parent : null;
      if (this.constructor === Directive) {
        throw new Error("Class Directive is an Abstract Class");
      }
      this["static"] = this.constructor;
      if (this.input !== null) {
        if ((_base = this["static"]).regex == null) {
          _base.regex = new RegExp("#" + this.symbol + " " + this.input);
        }
      } else {
        if ((_base1 = this["static"]).regex == null) {
          _base1.regex = new RegExp("#" + this.symbol);
        }
      }
    }

    Directive.prototype.canHandle = function(text) {
      var result;
      if ((result = this["static"].regex.exec(text)) !== null) {
        return true;
      } else {
        return false;
      }
    };

    Directive.prototype.getDirective = function(text) {
      var key, obj, result, string, stringSplit, value;
      result = this["static"].regex.exec(text);
      string = result[0];
      stringSplit = string.split(" ");
      key = stringSplit.shift();
      value = stringSplit.join(" ");
      obj = {
        key: key,
        value: value
      };
      return obj;
    };

    return Directive;

  })();

  exports.Directive = Directive;

  CustomDirective = (function(_super) {
    __extends(CustomDirective, _super);

    function CustomDirective(symbol, input) {
      CustomDirective.__super__.constructor.call(this, symbol, input);
      if (this.input !== null) {
        this["static"] = this;
        this["static"].regex = new RegExp("#" + this.symbol + " " + this.input);
      } else {
        this["static"].regex = new RegExp("#" + this.symbol);
      }
    }

    return CustomDirective;

  })(Directive);

  exports.CustomDirective = CustomDirective;

  StopDirective = (function(_super) {
    __extends(StopDirective, _super);

    function StopDirective() {
      StopDirective.__super__.constructor.call(this, "stop");
    }

    return StopDirective;

  })(Directive);

  exports.StopDirective = StopDirective;

  ChildDirective = (function(_super) {
    __extends(ChildDirective, _super);

    function ChildDirective() {
      ChildDirective.__super__.constructor.call(this, "child", "[^\s\r\n]+");
    }

    return ChildDirective;

  })(Directive);

  exports.ChildDirective = ChildDirective;

  NameDirective = (function(_super) {
    __extends(NameDirective, _super);

    function NameDirective() {
      NameDirective.__super__.constructor.call(this, "name", "[^\s\r\n]+");
    }

    return NameDirective;

  })(Directive);

  exports.NameDirective = NameDirective;

  RenderDirective = (function(_super) {
    __extends(RenderDirective, _super);

    function RenderDirective() {
      RenderDirective.__super__.constructor.call(this, "render");
    }

    return RenderDirective;

  })(Directive);

  exports.RenderDirective = RenderDirective;

  SectionDirective = (function(_super) {
    __extends(SectionDirective, _super);

    function SectionDirective() {
      SectionDirective.__super__.constructor.call(this, "section", "[^\s\r\n]+");
    }

    return SectionDirective;

  })(Directive);

  exports.SectionDirective = SectionDirective;

  RepeatDirective = (function(_super) {
    __extends(RepeatDirective, _super);

    function RepeatDirective() {
      RepeatDirective.__super__.constructor.call(this, "repeat", "[0-9]+");
    }

    return RepeatDirective;

  })(Directive);

  exports.RepeatDirective = RepeatDirective;

  ParentDirective = (function(_super) {
    __extends(ParentDirective, _super);

    function ParentDirective() {
      ParentDirective.__super__.constructor.call(this, "parent", "[^\s\r\n]+");
    }

    return ParentDirective;

  })(Directive);

  exports.ParentDirective = ParentDirective;

  NeedDirective = (function(_super) {
    __extends(NeedDirective, _super);

    function NeedDirective() {
      NeedDirective.__super__.constructor.call(this, "need", "[^\s\r\n]+");
    }

    return NeedDirective;

  })(Directive);

  exports.NeedDirective = NeedDirective;

  fs = require("fs");

  MegaFile = require("mega-reader").MegaFile;

  async = require("async");

  mkdirp = require("mkdirp");

  path = require("path");

  os = require("os");

  RenderLine = (function() {
    function RenderLine(name, stack) {
      this.name = name;
      this.stack = stack;
      process.output.debug("renderline " + this.name + " created");
      this.path = "./preview";
      this.line = [];
    }

    RenderLine.prototype.clear = function() {
      this.position = -1;
      this.tools = [];
      return this.readers = [];
    };

    RenderLine.prototype.buildReaders = function() {
      var file, _i, _len, _ref, _results;
      _ref = this.line;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        file = _ref[_i];
        _results.push(this.readers.push(new MegaFile([file.filename])));
      }
      return _results;
    };

    RenderLine.prototype.buildtools = function() {
      var tool, _i, _len, _ref, _results;
      _ref = [new NeedDirective, new ParentDirective, new RepeatDirective, new SectionDirective, new NameDirective, new ChildDirective, new RenderDirective, new StopDirective];
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        tool = _ref[_i];
        _results.push(this.tools.push(tool));
      }
      return _results;
    };

    RenderLine.prototype.shift = function() {
      return this.line.shift();
    };

    RenderLine.prototype.unshift = function(item) {
      return this.line.unshift(item);
    };

    RenderLine.prototype.push = function(item) {
      return this.line.push(item);
    };

    RenderLine.prototype.pop = function(item) {
      return this.line.pop(item);
    };

    RenderLine.prototype.position = null;

    RenderLine.prototype.internalLine = function(text) {
      var tool, value, _i, _len, _ref;
      value = null;
      _ref = this.tools;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        tool = _ref[_i];
        if (tool.canHandle(text)) {
          value = tool;
          break;
        }
      }
      return value;
    };

    RenderLine.prototype.makefile = function() {
      if (!fs.existsSync(this.path)) {
        mkdirp.sync(this.path);
      }
      return fs.openSync(this.previewFile(), "w");
    };

    RenderLine.prototype.previewFile = function() {
      return "" + this.path + path.sep + this.name + ".html";
    };

    RenderLine.prototype.printFile = function(file, reader, repeat) {
      var directive, line, stop;
      if (repeat == null) {
        repeat = 1;
      }
      while (true) {
        process.output.debug("--------------------------------");
        process.output.debug("" + repeat + "," + reader.files);
        stop = false;
        if (reader.hasNextLine()) {
          line = reader.getNextLine();
          process.output.debug("" + line);
          directive = this.internalLine(line);
          if (!directive) {
            fs.writeSync(file, "" + line + os.EOL);
          } else if (directive instanceof ChildDirective) {
            this.printChild(file, directive.getDirective(line));
          } else if (directive instanceof NeedDirective) {
            this.printNeed(file, directive.getDirective(line).value);
          } else if (directive instanceof StopDirective) {
            stop = true;
          }
        }
        if (reader.hasNextLine()) {
          if (!stop) {
            continue;
          }
        }
        if (repeat > 0) {
          reader.reset();
          repeat--;
        }
        if (repeat <= 0) {
          break;
        }
      }
      return process.debug = false;
    };

    RenderLine.prototype.printRenderFile = function(file) {
      var reader, repeat;
      this.position++;
      repeat = this.line[this.position].repeat;
      reader = this.readers[this.position];
      this.printFile(file, reader, repeat);
      return this.position--;
    };

    RenderLine.prototype.printChild = function(file, secDirective) {
      var cd, line, reader;
      this.position++;
      reader = this.readers[this.position];
      reader.reset();
      cd = new CustomDirective(secDirective.key.replace("#child", "section"), secDirective.value);
      process.output.debug("" + (JSON.stringify(secDirective)));
      while (true) {
        if (reader.hasNextLine()) {
          line = reader.getNextLine();
          if (!cd.canHandle(line)) {
            continue;
          }
        }
        break;
      }
      this.position--;
      return this.printRenderFile(file);
    };

    RenderLine.prototype.printNeed = function(file, need) {
      var f, reader, _i, _len, _ref;
      reader = null;
      _ref = this.stack;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        f = _ref[_i];
        if (!(f.name === need)) {
          continue;
        }
        reader = f;
        break;
      }
      return this.printFile(file, new MegaFile([reader.filename]), reader.repeat);
    };

    RenderLine.prototype.render = function() {
      var file;
      this.clear();
      this.buildtools();
      this.buildReaders();
      file = this.makefile();
      this.printRenderFile(file);
      return fs.closeSync(file);
    };

    RenderLine.prototype.toString = function() {
      var l, obj, str, _i, _len, _ref;
      obj = [];
      _ref = this.line;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        l = _ref[_i];
        obj.push(l.toString());
      }
      str = obj.join(",\n");
      return str;
    };

    return RenderLine;

  })();

  exports.RenderLine = RenderLine;

  async = require("async");

  DirectoryManager = (function() {
    function DirectoryManager(fileManager) {
      this.fileManager = fileManager;
      process.output.debug("entering DirectoryManager " + (Date.now()));
      this.files = [];
      this.dirRead = require('node-dir');
      this.add = this.add.bind(this);
      this.loadFiles = this.loadFiles.bind(this);
    }

    DirectoryManager.prototype.watchDirectory = function() {};

    DirectoryManager.prototype.loadFiles = function(directory, match, exclude, loadFileFinished) {
      var readDirFinished;
      if (match == null) {
        match = null;
      }
      if (exclude == null) {
        exclude = null;
      }
      if (loadFileFinished == null) {
        loadFileFinished = null;
      }
      process.output.debug("getting ready to load the files");
      readDirFinished = (function(_this) {
        return function(err, files) {
          var after, afterIterator, iterator;
          process.output.debug("we have finished reading the directory and now wish to process the files");
          iterator = function(file, fileProcessed) {
            if (match === null || (new RegExp(match)).exec(file)) {
              if (exclude === null || (new RegExp(exclude)).exec(file) === null) {
                process.output.debug("moving on to process file " + file);
                return _this.add(file, fileProcessed);
              } else {
                return fileProcessed.call();
              }
            } else {
              return fileProcessed.call();
            }
          };
          iterator = iterator.bind(_this);
          afterIterator = function(file, fileBuilt) {
            return file.build(fileBuilt);
          };
          after = function() {
            return async.each(_this.files, afterIterator, loadFileFinished);
          };
          return async.each(files, iterator, after);
        };
      })(this);
      readDirFinished = readDirFinished.bind(this);
      return this.dirRead.files(directory, readDirFinished);
    };

    DirectoryManager.prototype.add = function(file, callback) {
      return this.files.push(new FileManager(file, callback, this.files));
    };

    DirectoryManager.prototype.toString = function() {
      return "[DirectoryManager]";
    };

    return DirectoryManager;

  })();

  exports.DirectoryManager = DirectoryManager;

  fs = require('fs');

  Log = require('log');

  process.output = new Log('debug', fs.createWriteStream('my.log'));

}).call(this);
